module Garner
  module Mixins
    module Grape
      #
      # A cache that supports conditional GETs
      #
      # Borrows generously from http://themomorohoax.com/2009/01/07/using-stale-with-rails-to-return-304-not-modified
      # See also RFC 2616: http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.3.4
      #   for explanation of how If-Modified-Since and If-None-Match request headers are handled.
      #
      module Cache
      
        def cache_enabled?
          true
        end
  
        # cache a record
        def cache(options = {}, &block)
          unless cache_enabled?
            yield
          else
            binding, context = cache_binding_and_context(options)
            Garner::Cache::ObjectIdentity.cache(binding, context) do
              yield
            end
          end
        end
        
        # invalidate a cache record
        def invalidate(*args)
          Garner::Cache::ObjectIdentity.invalidate(* args)
        end
  
        def cache_or_304(options = {}, &block)
          unless cache_enabled?
            yield
          else
            binding, context = cache_binding_and_context(options)
            # metadata written in a previous GET
            metadata = Garner::Cache::ObjectIdentity.cache_metadata(binding, context)
            error!("Not Modified", 304) if metadata && fresh?(metadata)
            rc = cache(options, &block)
            # metadata has been generated by cache
            metadata = Garner::Cache::ObjectIdentity.cache_metadata(binding, context)
            if metadata
              self.last_modified = metadata[:last_modified]
              self.etag = metadata[:etag]
            end
            rc
          end
        end
  
        private
          
          def cache_binding_and_context(options)
            cache_context = {}
            cache_context.merge!(options.dup)
            cache_context[:request] = request
            cache_context[:version] = version if self.respond_to?(:version) && version
            cache_context.delete(:bind)
            cache_binding = (options || {})[:bind]
            cache_binding = cache_binding ? { :bind => cache_binding } : {}
            [ cache_binding, cache_context ]
          end

          def fresh?(metadata = {})
            case
            when if_modified_since && if_none_match
              not_modified?(metadata[:last_modified]) && etag_matches?(metadata[:etag])
            when if_modified_since
              not_modified?(metadata[:last_modified])
            when if_none_match
              etag_matches?(metadata[:etag])
            else
              false
            end
          end
    
          def if_modified_since
            if since = env["HTTP_IF_MODIFIED_SINCE"]
              Time.rfc2822(since) rescue nil
            end
          end

          def if_none_match
            env["HTTP_IF_NONE_MATCH"]
          end

          def not_modified?(modified_at)
            if_modified_since && modified_at && if_modified_since >= modified_at
          end

          def etag_matches?(etag)
            if_none_match && if_none_match == etag
          end
        
          def last_modified=(utc_time)
            return unless utc_time
            header "Last-Modified", utc_time.httpdate
          end
        
          def etag=(etag)
            return unless etag
            header "ETag", etag
          end
          
      end
    end
  end
end

